<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>由浅入深学习 Lisp 宏之实战篇 | Keep Writing Codes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">由浅入深学习 Lisp 宏之实战篇</h1><a id="logo" href="/.">Keep Writing Codes</a><p class="description">Lisp 追随者，SICP 受益者，持续分享编程心得</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">由浅入深学习 Lisp 宏之实战篇</h1><div class="post-meta">Oct 1, 2017<span> | </span><span class="category"><a href="/categories/PL/">编程语言</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="blog/2017/10/01/macro-in-action/" href="/blog/2017/10/01/macro-in-action/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-as-data"><span class="toc-number">1.</span> <span class="toc-text">Code as data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#syntax-quote-amp-unquote"><span class="toc-number">1.1.</span> <span class="toc-text">syntax-quote & unquote</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Macro-Rules-of-Thumb"><span class="toc-number">2.</span> <span class="toc-text">Macro Rules of Thumb</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#In-Action"><span class="toc-number">3.</span> <span class="toc-text">In Action</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-gensym-保证宏-Hygiene"><span class="toc-number">3.1.</span> <span class="toc-text">使用 gensym 保证宏 Hygiene</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Macro-writing-macro"><span class="toc-number">3.2.</span> <span class="toc-text">Macro-writing macro</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用辅助函数定义简化宏"><span class="toc-number">3.3.</span> <span class="toc-text">使用辅助函数定义简化宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>本文是宏系列的第二篇文章，侧重于实战，对于新手建议先阅读宏系列的<a href="/blog/2017/08/31/master-macro-theory/">理论篇</a>，之后再来看本文。当然如果你有一定基础，也可以直接阅读本文。<br>其次，希望读者能把本文的 Clojure 代码手动敲到 REPL 里面去运行、调试，直到完全理解。</p>
<h2 id="Code-as-data"><a href="#Code-as-data" class="headerlink" title="Code as data"></a>Code as data</h2><p>在<a href="/blog/2017/08/31/master-macro-theory/">理论篇</a>中，介绍了宏（macro）的本质：<code>在编译时期运行的函数</code>。宏相对于普通函数，具有如下特点：</p>
<ol>
<li>宏的参数不会求值（eval），是 symbol 字面量</li>
<li>宏的返回值是 code（在运行期执行），不是一般的数据。</li>
</ol>
<p>这两条特性蕴含着一非常重要的思想： <a href="https://en.wikipedia.org/wiki/Homoiconicity" target="_blank" rel="external">code as data</a> ，也被称为同像性（homoiconicity，来自希腊语单词 homo，意为与符号含义表示相同）。同像性使得在 Lisp 中去操作语法树（AST）显得十分自然，而这在非 Lisp 语言只能由编译器（Compiler）去操作。这里举一典型的例子：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> when [test &amp; body]</div><div class="line">  (<span class="name"><span class="builtin-name">list</span></span> 'if test (<span class="name"><span class="builtin-name">cons</span></span> 'do body)))</div></pre></td></tr></table></figure>
<p><code>&#39;</code>代表 quote，作用是阻止后面的表达式求值，如果不使用<code>&#39;</code>的话，在进行<code>(list &#39;if test ...)</code>求值时会报错，因为对 special form 单独进行求值是非法的，这里需要的仅仅是 <code>if</code> 字面量，list 函数执行后的结果（是一个 list）作为 code 插入到调用 when 的地方去执行。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">even?</span></span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">100</span>))</div><div class="line">  (<span class="name">println</span> <span class="string">"good luck!"</span>)</div><div class="line">  (<span class="name">println</span> <span class="string">"lisp rocks!"</span>))</div><div class="line"></div><div class="line"><span class="comment">;; when 展开后的形式 </span></div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">even?</span></span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">100</span>))</div><div class="line">  (<span class="name"><span class="builtin-name">do</span></span> (<span class="name">println</span> <span class="string">"good luck!"</span>) (<span class="name">println</span> <span class="string">"lisp rocks!"</span>)))</div></pre></td></tr></table></figure>
<h3 id="syntax-quote-amp-unquote"><a href="#syntax-quote-amp-unquote" class="headerlink" title="syntax-quote &amp; unquote"></a>syntax-quote &amp; unquote</h3><p>对于一些简单的宏，可以采用像 when 那样的方式，使用 list 函数来形成要返回的 code，但对于复杂的宏，使用 list 函数来表示，会显得十分麻烦，看下 when-let 的实现：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> when-let [bindings &amp; body]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [form (<span class="name">bindings</span> <span class="number">0</span>) tst (<span class="name">bindings</span> <span class="number">1</span>)]</div><div class="line">    `(<span class="name"><span class="builtin-name">let</span></span> [temp# ~tst]</div><div class="line">       (<span class="name"><span class="builtin-name">when</span></span> temp#</div><div class="line">         (<span class="name"><span class="builtin-name">let</span></span> [~form temp#]</div><div class="line">           ~@body)))))</div></pre></td></tr></table></figure>
<p>这里返回的 list 使用 <em>`</em>（backtick）进行了修饰，这称为 syntax-quote，它与 quote <code>&#39;</code> 类似，只不过在阻止表达式求值的同时，支持以下两个额外功能：</p>
<ol>
<li>表达式里的所有 symbol 会在当前 namespace 中进行 resolve，返回 fully-qualified symbol</li>
<li>允许通过 <code>~</code>(unquote) 或 <code>~@</code>(slicing-unquote) 阻止部分表达式的 quote，以达到对它们求值的效果</li>
</ol>
<p>可以通过下面一个例子来了解它们之间的区别：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(let [x '(* 2 3) y x]</div><div class="line">  (println `y)</div><div class="line">  (println ``y)</div><div class="line">  (println ``~y)</div><div class="line">  (println ``~~y)</div><div class="line">  (println (eval ``~~y))</div><div class="line">  (println `[~@y]))</div><div class="line"></div><div class="line">;; 依次输出</div><div class="line"></div><div class="line">user/y</div><div class="line">(quote user/y)</div><div class="line">user/y</div><div class="line">(* 2 3)</div><div class="line">6</div><div class="line">[* 2 3]</div></pre></td></tr></table></figure>
<p>这里尤其要注意理解嵌套 syntax-quote 的情况，为了得到正确的值，需要 unquote 相应的次数（上例中的第四个println），这在 macro-writing macro 中十分有用，后面会介绍的。<br>最后需要注意一点，在整个 Clojure 程序生命周期中，<code>(syntax-)quote</code>, <code>(slicing-)unquote</code> 是 <a href="https://clojure.org/reference/reader" target="_blank" rel="external">Reader</a> 来解析的，详见 <a href="/blog/2017/02/05/clojure-compiler-analyze/#编译器工作流程">编译器工作流程</a>。可以通过<code>read-string</code>来验证：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">user&gt; (read-string "`y")</div><div class="line">(quote user/y)</div><div class="line">user&gt; (read-string "``y")</div><div class="line">(clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) </div><div class="line">                                       (clojure.core/list (quote user/y))))</div><div class="line">user&gt; (read-string "``~y")</div><div class="line">(quote user/y)</div><div class="line">user&gt; (read-string "``~~y")</div><div class="line">y</div></pre></td></tr></table></figure>
<h2 id="Macro-Rules-of-Thumb"><a href="#Macro-Rules-of-Thumb" class="headerlink" title="Macro Rules of Thumb"></a>Macro Rules of Thumb</h2><p>在正式实战前，这里摘抄 JoyOfClojure 一书中关于写宏的一般准则：</p>
<ol>
<li>如果函数能完成相应功能，不要写宏。在需要构造语法抽象（比如<code>when</code>）或新的binding 时再去用宏</li>
<li>写一个宏使用的 demo，并手动展开</li>
<li>使用<code>macroexpand</code>, <code>macroexpand-1</code> 与 <code>clojure.walk/macroexpand-all</code> 去验证宏是如何工作的</li>
<li>在 REPL 中测试</li>
<li>如果一个宏比较复杂，尽可能拆分成多个函数</li>
</ol>
<p>希望读者在写/读宏遇到困难时，思考是否对应了上述准则。</p>
<h2 id="In-Action"><a href="#In-Action" class="headerlink" title="In Action"></a>In Action</h2><p>前面介绍过，宏的一大应用场景是流程控制，比如上面介绍的 when、when-let，以及各种 do 的衍生品 dotimes、doseq，所以实战也从这里入手，构造一系列 do-primes，通过对它不断的完善修改，介绍写宏的技巧与注意事项。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">do-primes</span> [n start end]</div><div class="line">  body)</div></pre></td></tr></table></figure>
<p>上面是 do-primes 的使用方式，它会遍历 <code>[start, end)</code> 范围内的素数，对于具体素数 n，执行 body 里面的内容。</p>
<h3 id="使用-gensym-保证宏-Hygiene"><a href="#使用-gensym-保证宏-Hygiene" class="headerlink" title="使用 gensym 保证宏 Hygiene"></a>使用 gensym 保证宏 Hygiene</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> prime? [n]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [guard (<span class="name"><span class="builtin-name">int</span></span> (<span class="name">Math/ceil</span> (<span class="name">Math/sqrt</span> n)))]</div><div class="line">    (<span class="name"><span class="builtin-name">loop</span></span> [i <span class="number">2</span>]</div><div class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">zero?</span></span> (<span class="name"><span class="builtin-name">mod</span></span> n i))</div><div class="line">        <span class="literal">false</span></div><div class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> i guard)</div><div class="line">          <span class="literal">true</span></div><div class="line">          (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">inc</span></span> i)))))))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> next-prime [n]</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">prime?</span> n)</div><div class="line">    n</div><div class="line">    (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">inc</span></span> n))))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes [[variable start end] &amp; body]</div><div class="line">  `(<span class="name"><span class="builtin-name">loop</span></span> [~variable ~start]</div><div class="line">     (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable ~end)</div><div class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</div><div class="line">         ~@body)</div><div class="line">       (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable))))))</div></pre></td></tr></table></figure>
<p>上面的实现比较直接，首先定义了两个辅助函数，然后通过返回由 loop 构成的 code 来达到遍历的效果。简单测试下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">do-primes</span> [n <span class="number">2</span> <span class="number">13</span>]</div><div class="line">  (<span class="name">println</span> n))</div><div class="line"></div><div class="line"><span class="comment">;; 展开为</span></div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">loop</span></span> [n <span class="number">2</span>]</div><div class="line">  (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n <span class="number">13</span>)</div><div class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</div><div class="line">    (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n)))))</div><div class="line"></div><div class="line"><span class="comment">;; 最终输出 3 5 7 11</span></div></pre></td></tr></table></figure>
<p>达到预期。但上述实现有些问题：end 在循环中进行比较时多次进行了求值，如果传入的 end 不是固定的数字，而是一个函数，而我们又无法确定这个函数有无副作用，这就可能产生问题。<br>也许你会说，这个解决也很简单，在进行 loop 之前，用一个 let 先把 end 的值先算出来就可以了。这个确实能解决多次执行的问题，但是又引入另一个隐患：<strong>end 先于 start 执行</strong>。这会不会产生不良后果，我们同样无法预知，我们能做到的就是<strong>尽量不用暴露宏的实现细节</strong>，具体表现就是<strong>保证宏参数的求值顺序</strong>。所以有了下面的修改：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes2 [[variable start end] &amp; body]</div><div class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [start# ~start</div><div class="line">         end# ~end]</div><div class="line">     (<span class="name"><span class="builtin-name">loop</span></span> [~variable start#]</div><div class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable end#)</div><div class="line">         (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</div><div class="line">           ~@body)</div><div class="line">         (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</div><div class="line"></div><div class="line">(<span class="name">do-primes2</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</div><div class="line">  (<span class="name">println</span> n))</div><div class="line"><span class="comment">;; 展开为</span></div><div class="line">(<span class="name"><span class="builtin-name">let</span></span> [start__17380__auto__ <span class="number">2</span> end__17381__auto__ (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</div><div class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n start__17380__auto__]</div><div class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n end__17381__auto__)</div><div class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</div><div class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</div></pre></td></tr></table></figure>
<p>在 syntax-quote 里面，使用了 <code>name#</code> 的形式来定义 locals，这是 gensym 机制，用来生成全局唯一的 symbol，保证宏的“卫生”（<a href="http://clojure-doc.org/articles/language/macros.html#macro-hygiene-and-gensym" target="_blank" rel="external">hygiene</a>）。如果这里不使用 gensym，在 Common Lisp 里面可能会污染全局里面的同名变量，在 Clojure 里面，为了避免污染全局环境，name 部分会 resolve 成当前命名空间里面的变量，例如</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes2-danger [[variable start end] &amp; body]</div><div class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [inner-start ~start</div><div class="line">         inner-end ~end]</div><div class="line">     (<span class="name"><span class="builtin-name">loop</span></span> [~variable inner-start]</div><div class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable inner-end)</div><div class="line">         (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</div><div class="line">           ~@body)</div><div class="line">         (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</div><div class="line"></div><div class="line">(<span class="name">do-primes2-danger</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</div><div class="line">                        (<span class="name">println</span> n))</div><div class="line"><span class="comment">;; 展开为</span></div><div class="line">(<span class="name"><span class="builtin-name">let</span></span> [user/inner-start <span class="number">2</span></div><div class="line">      user/inner-end (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</div><div class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n user/inner-start] </div><div class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n user/inner-end) </div><div class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) </div><div class="line">        (<span class="name">println</span> n))</div><div class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</div></pre></td></tr></table></figure>
<p>通过宏展开的代码可以看到，这明显不是我们想要的，运行上述代码会直接报错<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java<span class="selector-class">.lang</span><span class="selector-class">.RuntimeException</span>：Can<span class="string">'t let qualified name: user/inner-start</span></div></pre></td></tr></table></figure></p>
<p>所以在定义内部 locals 时，一定要用 gensym 机制。如果能确保使用的名字不会造成污染，也可以使用 <code>~&#39;name</code> 的形式来避免 resolve 这一过程。<code>~&#39;name</code> 其实就是 <code>~(quote name)</code> 的简写，它在 syntax-quote 里面求值的结果就是 symbol 字面量 <code>name</code>：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes2-safe [[variable start end] &amp; body]</div><div class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [~'inner-start ~start</div><div class="line">         ~'inner-end ~end]</div><div class="line">     (<span class="name"><span class="builtin-name">loop</span></span> [~variable ~'inner-start]</div><div class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable ~'inner-end)</div><div class="line">         (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</div><div class="line">           ~@body)</div><div class="line">         (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</div><div class="line"></div><div class="line">(<span class="name">do-primes2-safe</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</div><div class="line">                 (<span class="name">println</span> n))</div><div class="line"><span class="comment">;; 展开为</span></div><div class="line">(<span class="name"><span class="builtin-name">let</span></span> [inner-start <span class="number">2</span> inner-end (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</div><div class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n inner-start]</div><div class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n inner-end)</div><div class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</div><div class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</div></pre></td></tr></table></figure>
<h3 id="Macro-writing-macro"><a href="#Macro-writing-macro" class="headerlink" title="Macro-writing macro"></a>Macro-writing macro</h3><p>通过上面的例子，我们知道，gensym 是一种非常实用的技巧，所以我们完全有可能再进行一次抽象，构造 only-once 宏，来保证传入的参数按照顺序只求值一次：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> only-once [names &amp; body]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [gensyms (<span class="name">repeatedly</span> (<span class="name"><span class="builtin-name">count</span></span> names) gensym)]</div><div class="line">    `(<span class="name"><span class="builtin-name">let</span></span> [~@(<span class="name">interleave</span> gensyms (<span class="name"><span class="builtin-name">repeat</span></span> '(<span class="name"><span class="builtin-name">gensym</span></span>)))]</div><div class="line">       `(<span class="name"><span class="builtin-name">let</span></span> [~~@(<span class="name"><span class="builtin-name">mapcat</span></span> #(<span class="name"><span class="builtin-name">list</span></span> %<span class="number">1</span> %<span class="number">2</span>) gensyms names)]</div><div class="line">          ~(<span class="name"><span class="builtin-name">let</span></span> [~@(<span class="name"><span class="builtin-name">mapcat</span></span> #(<span class="name"><span class="builtin-name">list</span></span> %<span class="number">1</span> %<span class="number">2</span>) names gensyms)]</div><div class="line">             ~@body)))))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes3 [[variable start end] &amp; body]</div><div class="line">  (<span class="name">only-once</span> [start end]</div><div class="line">             `(<span class="name"><span class="builtin-name">loop</span></span> [~variable ~start]</div><div class="line">                (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable ~end)</div><div class="line">                  (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</div><div class="line">                    ~@body)</div><div class="line">                  (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</div><div class="line"></div><div class="line">(<span class="name">do-primes3</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</div><div class="line">  (<span class="name">println</span> n))</div><div class="line"></div><div class="line"><span class="comment">;; 展开为</span></div><div class="line">(<span class="name"><span class="builtin-name">let</span></span> [G__18605 <span class="number">2</span> G__18606 (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</div><div class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n G__18605]</div><div class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n G__18606)</div><div class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</div><div class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</div></pre></td></tr></table></figure>
<p>only-once 的核心思想是用 gensym 来替换掉传入的 symbol（即 names），为了达到这种效果，它首先定义出一组与参数数目相同的 gensyms（分别记为#s1 #s2），然后在第二层 let 为这些 gensyms 做 binding，value 也是用 gensym 生成的（分别记为#s3 #s4），这一层的 let 的返回值将内嵌到 do-primes3 内：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">let</span></span> [#s1 #s3 #s2 #s4]</div><div class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [#s3 ~start #s3 ~end]</div><div class="line">    (<span class="name"><span class="builtin-name">let</span></span> [start #s1 end #s2]</div><div class="line">      ~@body)))</div></pre></td></tr></table></figure>
<p>第三层 let 的结果作为 code 内嵌到调用 do-primes3 处，即最终的展开式：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">let</span></span> [#s3 <span class="number">2</span> #s4 (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</div><div class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n #s3]</div><div class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n #s4)</div><div class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</div><div class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</div></pre></td></tr></table></figure>
<p>根据上述分析过程，可以看到第四层嵌套的 let 先于第三层嵌套的 let 执行，第四层 let 做 binding 时，是把 #s1 对应的 #s3 赋值给 start，#s2 对应的 #s4 赋值给 end，这样就成功的实现了 symbol 的替换。</p>
<p>only-once 属于 macro-writing macro 的范畴，就是说它使用的对象本身还是个宏，所以有一定的难度，主要是分清不同表达式的求值环境，这一点对于理解这一类宏非常关键。不过这一类宏大家应该很少能见到，更多的时候是使用辅助函数来分解复杂宏。比如我们这里就使用了两个辅助函数 prime? next-prime 来简化宏的写法。下面一个例子会阐述这一点。</p>
<h3 id="使用辅助函数定义简化宏"><a href="#使用辅助函数定义简化宏" class="headerlink" title="使用辅助函数定义简化宏"></a>使用辅助函数定义简化宏</h3><p><code>def-watched</code> 可以定义一个受监控的 var，在 root binding 改变时打印前后的值</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> def-watched [name &amp; value]</div><div class="line">  `(<span class="name"><span class="builtin-name">do</span></span></div><div class="line">     (<span class="name"><span class="builtin-name">def</span></span> ~name ~@value)</div><div class="line">     (<span class="name"><span class="builtin-name">add-watch</span></span> (<span class="name"><span class="builtin-name">var</span></span> ~name)</div><div class="line">                <span class="symbol">:re-bind</span></div><div class="line">                (<span class="name"><span class="builtin-name">fn</span></span> [~'key ~'r old# new#]</div><div class="line">                  (<span class="name">println</span> '~name old# <span class="string">" -&gt; "</span> new#)))))</div><div class="line"></div><div class="line">(<span class="name">def-watched</span> foo <span class="number">1</span>)                  </div><div class="line">(<span class="name"><span class="builtin-name">def</span></span> foo <span class="number">2</span>)</div><div class="line"><span class="comment">;; 这时打印 foo 1  -&gt;  2</span></div></pre></td></tr></table></figure>
<p>为了简化 def-watched，可能会想把里面的函数提取出来：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> gen-watch-fn [name]</div><div class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [k r o n]</div><div class="line">    (<span class="name">println</span> name <span class="string">":"</span> o <span class="string">" -&gt; "</span> n)))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> def-watched2 [name &amp; value]</div><div class="line">  `(<span class="name"><span class="builtin-name">do</span></span></div><div class="line">     (<span class="name"><span class="builtin-name">def</span></span> ~name ~@value)</div><div class="line">     (<span class="name"><span class="builtin-name">add-watch</span></span> (<span class="name"><span class="builtin-name">var</span></span> ~name)</div><div class="line">                <span class="symbol">:re-bind</span> (<span class="name">gen-watch-fn</span> '~name))))</div><div class="line"></div><div class="line">(<span class="name">def-watched2</span> bar <span class="number">1</span>)                  </div><div class="line"><span class="comment">;; 展开为</span></div><div class="line">(<span class="name"><span class="builtin-name">do</span></span> (<span class="name"><span class="builtin-name">def</span></span> bar <span class="number">1</span>) (<span class="name"><span class="builtin-name">add-watch</span></span> #'bar <span class="symbol">:re-bind</span> (<span class="name">gen-watch-fn</span> 'bar)))</div></pre></td></tr></table></figure>
<p>这时的效果和上面是一样的，请注意这里是把 gen-watch-fn 实现为了函数，如果用宏的话，会有什么效果呢？<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; 将 gen-watch-fn 改为 defmacro，其他均不变 </span></div><div class="line"><span class="comment">;; (def-watched2 bar 1) 展开后变成了</span></div><div class="line">(<span class="name"><span class="builtin-name">do</span></span></div><div class="line">  (<span class="name"><span class="builtin-name">def</span></span> bar <span class="number">1</span>)</div><div class="line">  (<span class="name"><span class="builtin-name">add-watch</span></span></div><div class="line">    #'bar</div><div class="line">    <span class="symbol">:re-bind</span></div><div class="line">    #function[user/gen-watch-fn/fn--17288]))</div></pre></td></tr></table></figure></p>
<p>这直接会报 No matching ctor found for class #function[user/gen-watch-fn/fn–17288]，由于 gen-watch-fn 是宏，它返回的是 code，而不是一般的 data，这也就是问题发生的缘由。</p>
<p>回想本文一开始介绍的宏的两个特性：参数是否需要求值，返回值是 code 还是 data，这是决定是否用宏的关键。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文一开始就明确指出 Lisp 中 code as data 的特性，这一点表面看似比较好理解，但是放到具体环境中时，就十分容易搞错，所以还是要多写宏，实战岀真知。<br>实战部分介绍了一些注意事项以及管用技巧，引入了相比来说难以理解的 macro-writing marco，完全理解它有一定难度，但也不是无法入手，理清 quote unquote 的作用机制，并且在 REPL 中不断调试，肯定能有所收获。<br>虽说不推荐使用宏解决问题，但是在有些时候，一个简单的宏不仅仅能省掉好几十行代码，而且能使逻辑更清晰，这时候也就不要“吝啬”了。</p>
<p>最后，希望通过宏系列这两篇文章的介绍，大家能对宏有更深的理解。如果有问题，欢迎留言讨论！<br>Happy Lisp！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://8thlight.com/blog/colin-jones/2012/05/22/quoting-without-confusion.html" target="_blank" rel="external">Quoting Without Confusion</a></li>
<li><a href="https://clojure.org/reference/reader#syntax-quote" target="_blank" rel="external">https://clojure.org/reference/reader#syntax-quote</a></li>
<li><a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html" target="_blank" rel="external">http://www.gigamonkeys.com/book/macros-defining-your-own.html</a></li>
<li><a href="https://hubpages.com/technology/Clojure-macro-writing-macros" target="_blank" rel="external">https://hubpages.com/technology/Clojure-macro-writing-macros</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://liujiacai.net/blog/2017/10/01/macro-in-action/" data-id="cjbjer95y0047w2ljxl8c04x4" class="article-share-link">分享</a><div class="tags"><a href="/tags/Clojure/">Clojure</a></div><div class="post-nav"><a href="/blog/2017/11/22/create-firefox-chrome-extensions-in-clojurescript/" class="pre">使用 ClojureScript 开发浏览器插件的过程与收获</a><a href="/blog/2017/08/31/master-macro-theory/" class="next">由浅入深学习 Lisp 宏之理论篇</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'jiacai2050';
var disqus_identifier = 'blog/2017/10/01/macro-in-action/';
var disqus_title = '由浅入深学习 Lisp 宏之实战篇';
var disqus_url = 'http://liujiacai.net/blog/2017/10/01/macro-in-action/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//jiacai2050.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://liujiacai.net"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PL/">编程语言</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/gcd/" style="font-size: 15px;">gcd</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/最佳实践/" style="font-size: 15px;">最佳实践</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/regexp/" style="font-size: 15px;">regexp</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/马拉松/" style="font-size: 15px;">马拉松</a> <a href="/tags/千里路/" style="font-size: 15px;">千里路</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2017/11/22/create-firefox-chrome-extensions-in-clojurescript/">使用 ClojureScript 开发浏览器插件的过程与收获</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/10/01/macro-in-action/">由浅入深学习 Lisp 宏之实战篇</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/08/31/master-macro-theory/">由浅入深学习 Lisp 宏之理论篇</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/05/11/review-of-secret-of-silicon-valley/">《硅谷之谜》读后感</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/04/02/clojure-web-dev-ring-usage/">Clojure Web 开发-- Ring 使用指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/03/22/ace-technical-interview/">“玩转” 技术面试——链表的函数表示法</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/03/05/method-vs-proc-in-ruby/">辨析 Ruby 中的 Method 与 Proc</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/02/09/clojure-compiler-analyze-2/">Clojure 运行原理之字节码生成篇</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/02/05/clojure-compiler-analyze/">Clojure 运行原理之编译器剖析篇</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/01/08/review-2016/">2016 年终总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Keep Writing Codes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3ffc15f400ce3f8b1db5afc4f29b6ce9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>