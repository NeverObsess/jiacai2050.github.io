<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>Socket 编程实战 | Keep Writing Codes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Socket 编程实战</h1><a id="logo" href="/.">Keep Writing Codes</a><p class="description">Lisp 追随者，SICP 受益者，持续分享编程心得</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Socket 编程实战</h1><div class="post-meta">Oct 31, 2016<span> | </span><span class="category"><a href="/categories/aha-computer/">理解计算机</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="blog/2016/10/31/socket-programming/" href="/blog/2016/10/31/socket-programming/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-socket-API"><span class="toc-number">2.</span> <span class="toc-text">Python socket API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-socket"><span class="toc-number">2.1.</span> <span class="toc-text">TCP socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-socket"><span class="toc-number">2.2.</span> <span class="toc-text">UDP socket</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见陷阱"><span class="toc-number">3.</span> <span class="toc-text">常见陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#忽略返回值"><span class="toc-number">3.1.</span> <span class="toc-text">忽略返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#误认为-TCP-具有-framing"><span class="toc-number">3.2.</span> <span class="toc-text">误认为 TCP 具有 framing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-的状态机"><span class="toc-number">4.</span> <span class="toc-text">TCP 的状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实战"><span class="toc-number">5.</span> <span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-UA"><span class="toc-number">5.1.</span> <span class="toc-text">HTTP UA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unix-domain-socket"><span class="toc-number">5.2.</span> <span class="toc-text">Unix_domain_socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ping"><span class="toc-number">5.3.</span> <span class="toc-text">ping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat-vs-ss"><span class="toc-number">5.4.</span> <span class="toc-text">netstat vs ss</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>Socket 在英文中的含义为“（连接两个物品的）凹槽”，像<code>the eye socket</code>，意为“眼窝”，此外还有“插座”的意思。在计算机科学中，socket 通常是指一个连接的两个端点，这里的连接可以是同一机器上的，像<a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="external">unix domain socket</a>，也可以是不同机器上的，像<a href="https://en.wikipedia.org/wiki/Network_socket" target="_blank" rel="external">network socket</a>。</p>
<p>本文着重介绍现在用的最多的 network socket，包括其在网络模型中的位置、API 的编程范式、常见错误等方面，最后用 Python 语言中的 socket API 实现几个实际的例子。Socket 中文一般翻译为“套接字”，不得不说这是个让人摸不着头脑的翻译，我也没想到啥“信达雅”的翻译，所以本文直接用其英文表述。本文中所有代码均可在 <a href="https://github.com/jiacai2050/socket.py" target="_blank" rel="external">socket.py</a> 仓库中找到。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Socket 作为一种通用的技术规范，首次是由 Berkeley 大学在 1983 为 4.2BSD Unix 提供的，后来逐渐演化为 POSIX 标准。Socket API 是由操作系统提供的一个编程接口，让应用程序可以控制使用 socket 技术。Unix 哲学中有一条<code>一切皆为文件</code>，所以 <code>socket</code> 和 <code>file</code> 的 API 使用很类似：可以进行<code>read</code>、<code>write</code>、<code>open</code>、<code>close</code>等操作。</p>
<p>现在的网络系统是分层的，理论上有<a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="external">OSI模型</a>，工业界有<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" target="_blank" rel="external">TCP/IP协议簇</a>。其对比如下：</p>
<center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2V0wfbmqJ.eBjy1zbXXbx8FXa_!!581166664.gif" alt=" osi vs tcp/ip"><br></center><br>每层上都有其相应的协议，socket API 不属于TCP/IP协议簇，只是操作系统提供的一个用于网络编程的接口，工作在应用层与传输层之间：<br><center><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2fzkbbhmJ.eBjy0FhXXbBdFXa_!!581166664.gif" alt="where socket works in tcp/ip"><br></center>

<p>我们平常浏览网站所使用的http协议，收发邮件用的smtp与imap，都是基于 socket API 构建的。</p>
<p>一个 socket，包含两个必要组成部分：</p>
<ol>
<li>地址，由 ip 与 端口组成，像<code>192.168.0.1:80</code>。</li>
<li>协议，socket 所是用的传输协议，目前有三种：<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="external">TCP</a>、<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="external">UDP</a>、<a href="https://en.wikipedia.org/wiki/Raw_socket" target="_blank" rel="external">raw IP</a>。</li>
</ol>
<p>地址与协议可以确定一个socket；一台机器上，只允许存在一个同样的socket。TCP 端口 53 的 socket 与 UDP 端口 53 的 socket 是两个不同的 socket。</p>
<p>根据 socket 传输数据方式的不同（使用协议不同），可以分为以下三种：</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Stream_socket" target="_blank" rel="external">Stream sockets</a>，也称为“面向连接”的 socket，使用 TCP 协议。实际通信前需要进行连接，传输的数据没有特定的结构，所以高层协议需要自己去界定数据的分隔符，但其优势是数据是可靠的。</li>
<li><a href="https://en.wikipedia.org/wiki/Datagram_socket" target="_blank" rel="external">Datagram sockets</a>，也称为“无连接”的 socket，使用 UDP 协议。实际通信前不需要连接，一个优势时 UDP 的数据包自身是可分割的（self-delimiting），也就是说每个数据包就标示了数据的开始与结束，其劣势是数据不可靠。</li>
<li><a href="https://en.wikipedia.org/wiki/Raw_socket" target="_blank" rel="external">Raw sockets</a>，通常用在路由器或其他网络设备中，这种 socket 不经过TCP/IP协议簇中的传输层（transport layer），直接由网络层（Internet layer）通向应用层（Application layer），所以这时的数据包就不会包含 tcp 或 udp 头信息。<br><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2qOeFX3hJc1FjSZFDXXbvnFXa_!!581166664.png_310x310.jpg" alt=" 数据包在各个层间的变更"><br></center><h2 id="Python-socket-API"><a href="#Python-socket-API" class="headerlink" title="Python socket API"></a>Python socket API</h2></li>
</ol>
<p>Python 里面用<code>(ip, port)</code>的元组来表示 socket 的地址属性，用<code>AF_*</code>来表示协议类型。<br>数据通信有两组动词可供选择：<code>send/recv</code> 或 <code>read/write</code>。<code>read/write</code> 方式也是 Java 采用的方式，这里不会对这种方式进行过多的解释，但是需要注意的是：</p>
<blockquote>
<p><code>read/write</code> 操作的具有 buffer 的“文件”，所以在进行读写后需要调用<code>flush</code>方法去真正发送或读取数据，否则数据会一直停留在缓冲区内。</p>
</blockquote>
<h3 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h3><p>TCP socket 由于在通信前需要建立连接，所以其模式较 UDP socket 复杂些。具体如下：</p>
<center><br><img width="400px" height="700px" src="https://img.alicdn.com/imgextra/i1/581166664/TB2egBSbOKO.eBjSZPhXXXqcpXa_!!581166664.png_620x10000.jpg" alt="TCP socket API "><br></center>

<p>API 的具体含义这里不在赘述，可以查看<a href="https://en.wikipedia.org/wiki/Berkeley_sockets#Socket_API_functions" target="_blank" rel="external">手册</a>，这里给出 Python 语言实现的 echo server。</p>
<ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_tcp_echo/echo_server.py" target="_blank" rel="external">echo_server.py</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line"></div><div class="line">def handler(client_sock, addr):</div><div class="line">    try:</div><div class="line">        print(&apos;new client from %s:%s&apos; % addr)</div><div class="line">        msg = client_sock.recv(100)</div><div class="line">        client_sock.send(msg)</div><div class="line">        print(&apos;received data[%s] from %s:%s&apos; % ((msg,) + addr))</div><div class="line">    finally:</div><div class="line">        client_sock.close()</div><div class="line">        print(&apos;client[%s:%s] socket closed&apos; % addr)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    # 设置 SO_REUSEADDR 后,可以立即使用 TIME_WAIT 状态的 socket</div><div class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div class="line">    sock.bind((&apos;&apos;, 5500))</div><div class="line">    sock.listen(5)</div><div class="line"></div><div class="line">    while 1:</div><div class="line">        client_sock, addr = sock.accept()</div><div class="line">        handler(client_sock, addr)</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_tcp_echo/echo_client.py" target="_blank" rel="external">echo_client.py</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import socket</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">    data_to_sent = &apos;hello tcp socket&apos;</div><div class="line">    try:</div><div class="line">        sock.connect((&apos;&apos;, 5500))</div><div class="line"></div><div class="line">        sent = sock.send(data_to_sent)</div><div class="line">        print(sock.recv(1024))</div><div class="line">    finally:</div><div class="line">        sock.close()</div><div class="line">print(&apos;socket closed&apos;)</div></pre></td></tr></table></figure>
<p>上面代码有一点需要注意：server 端的 socket 设置了<code>SO_REUSEADDR</code>为1，目的是可以立即使用处于<code>TIME_WAIT</code>状态的socket，那么<code>TIME_WAIT</code>又是什么意思呢？后面在讲解 <a href="#TCP_的状态机">tcp 状态机</a>时再做详细介绍。</p>
<h3 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a>UDP socket</h3><center><br><img width="400px" height="400px" src="https://img.alicdn.com/imgextra/i3/581166664/TB2.pEmbmGI.eBjSspcXXcVjFXa_!!581166664.jpg_620x10000.jpg" alt=" udp_socket_api"><br></center>

<p>UDP 版的 socket server 的代码在进行<code>bind</code>后，无需调用<code>listen</code>方法。</p>
<ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_udp_echo/echo_server.py" target="_blank" rel="external">udp_echo_server.py</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line"># 设置 SO_REUSEADDR 后,可以立即使用 TIME_WAIT 状态的 socket</div><div class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div class="line">sock.bind((&apos;&apos;, 5500))</div><div class="line"># 没有调用 listen</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    while 1:</div><div class="line">        data, addr = sock.recvfrom(1024)</div><div class="line"></div><div class="line">        print(&apos;new client from %s:%s&apos; % addr)</div><div class="line">        sock.sendto(data, addr)</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_udp_echo/echo_client.py" target="_blank" rel="external">udp_echo_client.py</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import socket</div><div class="line"></div><div class="line">udp_server_addr = (&apos;&apos;, 5500)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line">    data_to_sent = &apos;hello udp socket&apos;</div><div class="line">    try:</div><div class="line">        sent = sock.sendto(data_to_sent, udp_server_addr)</div><div class="line">        data, server = sock.recvfrom(1024)</div><div class="line">        print(&apos;receive data:[%s] from %s:%s&apos; % ((data,) + server))</div><div class="line">    finally:</div><div class="line">        sock.close()</div></pre></td></tr></table></figure>
<h2 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h2><h3 id="忽略返回值"><a href="#忽略返回值" class="headerlink" title="忽略返回值"></a>忽略返回值</h3><p>本文中的 echo server 示例因为篇幅限制，也忽略了返回值。网络通信是个非常复杂的问题，通常无法保障通信双方的网络状态，很有可能在发送/接收数据时失败或部分失败。所以有必要对发送/接收函数的返回值进行检查。本文中的 tcp echo client 发送数据时，正确写法应该如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">total_send = 0</div><div class="line">content_length = len(data_to_sent)</div><div class="line">while total_send &lt; content_length:</div><div class="line">    sent = sock.send(data_to_sent[total_send:])</div><div class="line">    if sent == 0:</div><div class="line">        raise RuntimeError(&quot;socket connection broken&quot;)</div><div class="line">    total_send += total_send + sent</div></pre></td></tr></table></figure>
<p>同理，接收数据时也应该检查返回值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">chunks = []</div><div class="line">bytes_recd = 0</div><div class="line">while bytes_recd &lt; MSGLEN:   # MSGLEN 为实际数据大小</div><div class="line">    chunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))</div><div class="line">    if chunk == b&apos;&apos;:</div><div class="line">        raise RuntimeError(&quot;socket connection broken&quot;)</div><div class="line">    chunks.append(chunk)</div><div class="line">    bytes_recd = bytes_recd + len(chunk)</div><div class="line">return b&apos;&apos;.join(chunks)</div></pre></td></tr></table></figure>
<p><code>send/recv</code>操作的是网络缓冲区的数据，它们不必处理传入的所有数据。</p>
<blockquote>
<p>一般来说，当网络缓冲区填满时，<a href="https://docs.python.org/3/library/socket.html#socket.socket.send" target="_blank" rel="external">send函数</a>就返回了；当网络缓冲区被清空时，<a href="https://docs.python.org/3/library/socket.html#socket.socket.recv" target="_blank" rel="external">recv 函数</a>就返回。</p>
</blockquote>
<p>可以通过下面的方式设置缓冲区大小。</p>
<pre><code>s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, buffer_size)  # 发送
s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, buffer_size)  # 接受
</code></pre><h3 id="误认为-TCP-具有-framing"><a href="#误认为-TCP-具有-framing" class="headerlink" title="误认为 TCP 具有 framing"></a>误认为 TCP 具有 framing</h3><p>TCP 不提供 framing，这使得其很适合于传输数据流。这是其与 UDP 的重要区别之一。UDP 是一个面向消息的协议，能保持一条消息在发送者与接受者之间的完备性。</p>
<center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2SB4bbB9J.eBjy0FoXXXyvpXa_!!581166664.gif" alt="Framing capabilities of UDP and the lack of framing in TCP"><br></center>

<p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/tree/master/framing_assumptions" target="_blank" rel="external">framing_assumptions</a></p>
<h2 id="TCP-的状态机"><a href="#TCP-的状态机" class="headerlink" title="TCP 的状态机"></a>TCP 的状态机</h2><p>在前面echo server 的示例中，提到了TIME_WAIT状态，为了正式介绍其概念，需要了解下 TCP 从生成到结束的状态机。（<a href="https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.halu101/constatus.htm" target="_blank" rel="external">图片来源</a>）</p>
<center><br><img width="500px" height="600px" src="https://img.alicdn.com/imgextra/i2/581166664/TB2Us0HbNeK.eBjSZFlXXaywXXa_!!581166664.gif" alt=" tcp_state transition"><br></center>

<p>这个状图转移图非常非常关键，也比较复杂，我自己为了方便记忆，对这个图进行了拆解，仔细分析这个图，可以得出这样一个结论：</p>
<blockquote>
<p>连接的打开与关闭有被动（passive）与主动（active）两种情况。主动关闭时，涉及到的状态转移最多，包括FIN_WAIT_1、FIN_WAIT_2、CLOSING、TIME_WAIT。（是不是有种 no zuo no die 的感觉）</p>
</blockquote>
<p>此外，由于 TCP 是可靠的传输协议，所以每次发送一个数据包后，都需要得到对方的确认（ACK），有了上面这两个知识后，再来看下面的图：（<a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">图片来源</a>）</p>
<center><br><img width="400px" height="500px" src="https://img.alicdn.com/imgextra/i4/581166664/TB2nwCFbNaK.eBjSZFwXXXjsFXa_!!581166664.jpg" alt=" tcp 关闭时的状态转移时序图"><br></center>

<ol>
<li>在主动关闭连接的 socket 调用 <code>close</code>方法的同时，会向被动关闭端发送一个 FIN</li>
<li>对端收到FIN后，会向主动关闭端发送ACK进行确认，这时被动关闭端处于 CLOSE_WAIT 状态</li>
<li>当被动关闭端调用<code>close</code>方法进行关闭的同时向主动关闭端发送 FIN 信号，接收到 FIN 的主动关闭端这时就处于 TIME_WAIT 状态</li>
<li>这时主动关闭端不会立刻转为 CLOSED 状态，而是需要等待 2MSL（max segment life，一个数据包在网络传输中最大的生命周期），以确保被动关闭端能够收到最后发出的 ACK。如果被动关闭端没有收到最后的 ACK，那么被动关闭端就会重新发送 FIN，所以处于TIME_WAIT的主动关闭端会再次发送一个 ACK 信号，这么一来（FIN来）一回（ACK），正好是两个 MSL 的时间。如果等待的时间小于 2MSL，那么新的socket就可以收到之前连接的数据。</li>
</ol>
<p>前面 echo server 的示例也说明了，处于 TIME_WAIT 并不是说一定不能使用，可以通过设置 socket 的 <code>SO_REUSEADDR</code> 属性以达到不用等待 2MSL 的时间就可以复用socket 的目的，当然，这仅仅适用于测试环境，正常情况下不要修改这个属性。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="HTTP-UA"><a href="#HTTP-UA" class="headerlink" title="HTTP UA"></a>HTTP UA</h3><p>http 协议是如今万维网的基石，可以通过 socket API 来简单模拟一个浏览器（UA）是如何解析 HTTP 协议数据的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import socket</div><div class="line"></div><div class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">baidu_ip = socket.gethostbyname(&apos;baidu.com&apos;)</div><div class="line">sock.connect((baidu_ip, 80))</div><div class="line">print(&apos;connected to %s&apos; % baidu_ip)</div><div class="line"></div><div class="line">req_msg = [</div><div class="line">    &apos;GET / HTTP/1.1&apos;,</div><div class="line">    &apos;User-Agent: curl/7.37.1&apos;,</div><div class="line">    &apos;Host: baidu.com&apos;,</div><div class="line">    &apos;Accept: */*&apos;,</div><div class="line">]</div><div class="line">delimiter = &apos;\r\n&apos;</div><div class="line"></div><div class="line">sock.send(delimiter.join(req_msg))</div><div class="line">sock.send(delimiter)</div><div class="line">sock.send(delimiter)</div><div class="line"></div><div class="line">print(&apos;%sreceived%s&apos; % (&apos;-&apos;*20, &apos;-&apos;*20))</div><div class="line">http_response = sock.recv(4096)</div><div class="line">print(http_response)</div></pre></td></tr></table></figure>
<p>运行上面的代码可以得到下面的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">--------------------received--------------------</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Tue, 01 Nov 2016 12:16:53 GMT</div><div class="line">Server: Apache</div><div class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</div><div class="line">ETag: &quot;51-47cf7e6ee8400&quot;</div><div class="line">Accept-Ranges: bytes</div><div class="line">Content-Length: 81</div><div class="line">Cache-Control: max-age=86400</div><div class="line">Expires: Wed, 02 Nov 2016 12:16:53 GMT</div><div class="line">Connection: Keep-Alive</div><div class="line">Content-Type: text/html</div><div class="line"></div><div class="line">&lt;html&gt;</div><div class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><code>http_response</code>是通过直接调用<code>recv(4096)</code>得到的，万一真正的返回大于这个值怎么办？我们前面知道了 TCP 协议是面向流的，它本身并不关心消息的内容，需要应用程序自己去界定消息的边界，对于应用层的 HTTP 协议来说，有几种情况，最简单的一种时通过解析返回值头部的<code>Content-Length</code>属性，这样就知道<code>body</code>的大小了，对于 HTTP 1.1版本，支持<code>Transfer-Encoding: chunked</code>传输，对于这种格式，这里不在展开讲解，大家只需要知道， TCP 协议本身无法区分消息体就可以了。对这块感兴趣的可以查看 CPython 核心模块 <a href="https://github.com/python/cpython/blob/master/Lib/http/client.py" target="_blank" rel="external">http.client</a></p>
<h3 id="Unix-domain-socket"><a href="#Unix-domain-socket" class="headerlink" title="Unix_domain_socket"></a>Unix_domain_socket</h3><p>UDS 用于同一机器上不同进程通信的一种机制，其API适用与 network socket 很类似。只是其连接地址为本地文件而已。</p>
<p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/uds_server.py" target="_blank" rel="external">uds_server.py</a>、<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/uds_client.py" target="_blank" rel="external">uds_client.py</a></p>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>ping 命令作为检测网络联通性最常用的工具，其适用的传输协议既不是TCP，也不是 UDP，而是 <a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol" target="_blank" rel="external">ICMP</a>。<br>ICMP 消息（messages）通常用于诊断 IP 协议产生的错误，traceroute 命令也是基于 ICMP 协议实现。利用 Python raw sockets API 可以模拟发送 ICMP 消息，实现类似 ping 的功能。</p>
<p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/ping.py" target="_blank" rel="external">ping.py</a></p>
<h3 id="netstat-vs-ss"><a href="#netstat-vs-ss" class="headerlink" title="netstat vs ss"></a>netstat vs ss</h3><p>netstat 与 ss 是类 Unix 系统上查看 Socket 信息的命令。<br>netstat 是比较老牌的命令，我常用的选择有</p>
<ul>
<li><code>-t</code>，只显示 tcp 连接</li>
<li><code>-u</code>，只显示 udp 连接</li>
<li><code>-n</code>，不用解析hostname，用 IP 显示主机，可以加快执行速度</li>
<li><code>-p</code>，查看连接的进程信息</li>
<li><code>-l</code>，只显示监听的连接</li>
</ul>
<p>ss 是新兴的命令，其选项和 netstat 差不多，主要区别是能够进行过滤（通过<code>state</code>与<code>exclude</code>关键字）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ss -o state time-wait -n | head</div><div class="line">Recv-Q Send-Q             Local Address:Port               Peer Address:Port</div><div class="line">0      0                 10.200.181.220:2222              10.200.180.28:12865  timer:(timewait,33sec,0)</div><div class="line">0      0                      127.0.0.1:45977                 127.0.0.1:3306   timer:(timewait,46sec,0)</div><div class="line">0      0                      127.0.0.1:45945                 127.0.0.1:3306   timer:(timewait,6.621ms,0)</div><div class="line">0      0                 10.200.181.220:2222              10.200.180.28:12280  timer:(timewait,12sec,0)</div><div class="line">0      0                 10.200.181.220:2222              10.200.180.28:35045  timer:(timewait,43sec,0)</div><div class="line">0      0                 10.200.181.220:2222              10.200.180.28:42675  timer:(timewait,46sec,0)</div><div class="line">0      0                      127.0.0.1:45949                 127.0.0.1:3306   timer:(timewait,11sec,0)</div><div class="line">0      0                      127.0.0.1:45954                 127.0.0.1:3306   timer:(timewait,21sec,0)</div><div class="line">0      0               ::ffff:127.0.0.1:3306           ::ffff:127.0.0.1:45964  timer:(timewait,31sec,0)</div></pre></td></tr></table></figure>
<p>这两个命令更多用法可以参考：</p>
<ul>
<li><a href="http://www.cyberciti.biz/files/ss.html" target="_blank" rel="external">SS Utility: Quick Intro</a></li>
<li><a href="http://www.binarytides.com/linux-netstat-command-examples/" target="_blank" rel="external">10 basic examples of linux netstat command</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们的生活已经离不开网络，平时的开发也充斥着各种复杂的网络应用，从最基本的数据库，到各种分布式系统，不论其应用层怎么复杂，其底层传输数据的的协议簇是一致的。Socket 这一概念我们很少直接与其打交道，但是当我们的系统出现问题时，往往是对底层的协议认识不足造成的，希望这篇文章能对大家编程网络方面的程序有所帮助。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.python.org/3/howto/sockets.html" target="_blank" rel="external">Socket Programming HOWTO</a></li>
<li><a href="http://www.ibm.com/developerworks/library/l-sockpit/" target="_blank" rel="external">Five pitfalls of Linux sockets programming</a></li>
<li><a href="http://www.ibm.com/developerworks/linux/tutorials/l-sock/" target="_blank" rel="external">Programming Linux sockets, Part 1: Using TCP/IP</a></li>
<li><a href="http://stackoverflow.com/questions/10328675/how-to-know-content-length" target="_blank" rel="external">http://stackoverflow.com/questions/10328675/how-to-know-content-length</a></li>
<li><a href="http://electronicdesign.com/what-s-difference-between/what-s-difference-between-osi-seven-layer-network-model-and-tcpip" target="_blank" rel="external">What’s The Difference Between The OSI Seven-Layer Network Model And TCP/IP?</a></li>
<li><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">TCP 的那些事儿（上）</a></li>
<li><a href="https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html" target="_blank" rel="external">Coping with the TCP TIME-WAIT state on busy Linux servers</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://liujiacai.net/blog/2016/10/31/socket-programming/" data-id="cjae1vcqt003nttljgnopul5e" class="article-share-link">分享</a><div class="tags"><a href="/tags/python/">Python</a></div><div class="post-nav"><a href="/blog/2016/11/07/run-2-marathon-in-a-week/" class="pre">我为什么一周内连跑 2 个马拉松</a><a href="/blog/2016/06/30/python2-encoding/" class="next">Python2 中的编码问题</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'jiacai2050';
var disqus_identifier = 'blog/2016/10/31/socket-programming/';
var disqus_title = 'Socket 编程实战';
var disqus_url = 'http://liujiacai.net/blog/2016/10/31/socket-programming/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//jiacai2050.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://liujiacai.net"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PL/">编程语言</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/regexp/" style="font-size: 15px;">regexp</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/gcd/" style="font-size: 15px;">gcd</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/最佳实践/" style="font-size: 15px;">最佳实践</a> <a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/马拉松/" style="font-size: 15px;">马拉松</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/千里路/" style="font-size: 15px;">千里路</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2017/11/22/create-firefox-chrome-extensions-in-clojurescript/">使用 ClojureScript 开发浏览器插件</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/10/01/macro-in-action/">由浅入深学习 Lisp 宏之实战篇</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/08/31/master-macro-understand-symbol/">由浅入深学习 Lisp 宏之理论篇</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/05/11/review-of-secret-of-silicon-valley/">《硅谷之谜》读后感</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/04/02/clojure-web-dev-ring-usage/">Clojure Web 开发-- Ring 使用指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/03/22/ace-technical-interview/">“玩转” 技术面试——链表的函数表示法</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/03/05/method-vs-proc-in-ruby/">辨析 Ruby 中的 Method 与 Proc</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/02/09/clojure-compiler-analyze-2/">Clojure 运行原理之字节码生成篇</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/02/05/clojure-compiler-analyze/">Clojure 运行原理之编译器剖析篇</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/01/08/review-2016/">2016 年终总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Keep Writing Codes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3ffc15f400ce3f8b1db5afc4f29b6ce9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>